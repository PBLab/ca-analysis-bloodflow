import pathlib
from typing import List

import attr
from attr.validators import instance_of
import tifffile
import h5py
import numpy as np
import pandas as pd
from roipoly import roipoly
import matplotlib.pyplot as plt

from dff_calc.df_f_calculation import DffCalculator


@attr.s
class ManualRoiDrawing:
    """
    Calculate the raw fluorescence and dF/F of manually-drawn ROIs on a stack
    :param fname: data timelapse - .tif or .hdf5 (string)
    :param num_rois: number of ROIs to draw (integer)
    :param fps: frame rate (float)
    :param colors: list of colors to use
    :param scale: Distance between each cell trace corresponds to scale % of dF/F change. Default is 1, i.e. 100% dF/F
    """
    fname = attr.ib(validator=instance_of(str))
    num_rois = attr.ib(validator=instance_of(int))
    fps = attr.ib(default=7.68, validator=instance_of(float))
    colors = attr.ib(default=[f'C{idx}' for idx in range(10)])
    scale = attr.ib(default=1., validator=instance_of(float))
    data = attr.ib(init=False)
    rois = attr.ib(init=False)
    agg_data = attr.ib(init=False)
    raw_traces = attr.ib(init=False)
    dff = attr.ib(init=False)

    def run(self):
        self._load_data()
        self._offset_data()
        self._draw_rois()
        self._get_trace_from_masks()
        self.dff = DffCalculator(self.raw_traces, fps=self.fps).calc()
        self.dff = self.moving_average(self.dff, int(self.fps / 2))
        self._display_roi_with_trace()
        return self.dff

    def _load_data(self):
        """ Load different data formats into self.data """
        print(f"Loading {self.fname}...")
        if self.fname.endswith('.tif'):
            self.data = tifffile.imread(self.fname)
        elif self.fname.endswith('.h5') or self.fname.endswith('.hdf5'):
            with h5py.File(self.fname) as f:
                self.data = np.array(f['/Full Stack/Channel 1'])
        else:
            raise UserWarning(f'File type of {self.fname} not supported.')

    def _offset_data(self):
        """ Subtract the offset from the raw data """
        dt = self.data.dtype
        if (dt is np.uint32) or (dt is np.int32):
            self.data = self.data.astype(np.int64)

        if (dt is np.float32) or (dt is np.float16):
            self.data = self.data.astype(np.float64)

        self.data -= self.data.min()

    def _draw_rois(self):
        """
        Draw the ROIPoly on the data
        :return:
        """
        self.rois = []
        self.agg_data = self.data.mean(axis=0)
        for idx in range(self.num_rois):
            fig_rois, ax_rois = plt.subplots()
            ax_rois.imshow(self.agg_data, cmap='gray')
            for roi in self.rois:
                roi.displayROI()
            self.rois.append(roipoly(roicolor=self.colors[idx]))
            plt.show(block=True)

    def _get_trace_from_masks(self):
        """ Calculate the mean fluorescent trace in each ROI """
        self.raw_traces = np.zeros((self.num_rois, self.data.shape[0]))

        for idx, roi in enumerate(self.rois):
            cur_mask = roi.getMask(self.agg_data)
            self.raw_traces[idx, :] = np.mean(self.data[:, cur_mask], axis=-1)

    @staticmethod
    def moving_average(arr, n) :
        """ From https://stackoverflow.com/questions/14313510/how-to-calculate-moving-average-using-numpy """
        ret = np.cumsum(arr, axis=1, dtype=float)
        ret[:, n:] = ret[:, n:] - ret[:, :-n]
        return ret[:, n - 1:] / n

    def _display_roi_with_trace(self):
        """ Show the image of the average stack overlaid with the ROIs, and the dF/F values """
        num_of_frames = self.dff.shape[1]
        fig_cells, (ax_cells, ax_trace) = plt.subplots(1, 2)
        plt.sca(ax_cells)
        ax_cells.set_title("Field of View")
        ax_cells.imshow(self.agg_data, cmap='gray')
        for roi in self.rois:
            roi.displayROI()
        ax_cells.set_axis_off()
        max_time = num_of_frames / self.fps

        plt.sca(ax_trace)
        time_vec = np.arange(start=0, stop=max_time, step=1/self.fps)[:num_of_frames].reshape((1, num_of_frames))
        time_vec = np.tile(time_vec, (self.num_rois, 1))
        assert time_vec.shape == self.dff.shape

        # Plot fluorescence results
        trace_locs = np.linspace(start=0, stop=self.num_rois*self.scale, num=self.num_rois, endpoint=False)
        ax_trace.plot(time_vec.T, self.dff.T + trace_locs[np.newaxis, :], linewidth=0.3)
        ax_trace.set_xlabel("Time [sec]")
        ax_trace.set_ylabel("Cell ID")
        ax_trace.set_yticks(trace_locs + 0.2)
        ax_trace.set_yticklabels(np.arange(1, self.num_rois + 1))
        ax_trace.set_title(fr"$\Delta F / F$, scale={self.scale}")

        ax_trace.spines['top'].set_visible(False)
        ax_trace.spines['right'].set_visible(False)

        plt.savefig(f"rois_and_dff_{self.fname.split('/')[-1][:-4]}.pdf", transparent=True)


@attr.s
class ParseFijiRoiCsv:
    """
    A class designed to read the ROIs generated by Fiji's "ROI Manager"
    and convert them into a "standard" results.npz file that can be
    parsed by the other calcium analysis machinery.
    This class assumes that in Fiji the ROIs were analyzed with the
    "bounding box\\rectangle" measurement, and that they're named
    "*CHANNEL_x_rois.csv".
    """
    fname = attr.ib(validator=instance_of(pathlib.Path))
    movie = attr.ib(init=False)
    results_fname = attr.ib(init=False)
    channel_fname = attr.ib(init=False)

    def run(self):
        """ Main pipeline function """
        print(f"Parsing {self.fname}...")
        self.results_fname, self.channel_fname = self._generate_results_fname()
        if not self.results_fname:  # The file already exists
            return
        params = self._generate_params_dict()
        cn = self._generate_cn()
        crd = self._generate_crd()
        dff = self._extract_dff_from_masks(crd, params['fr'])
        self._write_results(params, cn, crd, dff)

    def _generate_results_fname(self):
        """
        Creates the filenames that will contain the numpy array and data, and
        that contain the channel-specific data.
        """
        fname = str(self.fname)

        results_fname = pathlib.Path(fname.replace("rois.csv", "results.npz"))
        channel_fname = pathlib.Path(fname.replace("_rois.csv", ".tif"))
        if results_fname.exists():
            return None, None
        return results_fname, channel_fname

    def _generate_params_dict(self):
        """ Generates the "params" dict which contains the general acquisition
        parameters.
        """
        return {
            "fr": 30.03,
            "fnames": str(self.results_fname),
        }

    def _generate_cn(self):
        """ Generates a time projection of the data to store in the
        "Cn" variable """
        self.movie = tifffile.imread(str(self.channel_fname))
        return self.movie.mean(0)

    def _generate_crd(self):
        """
        Generates the coordinates array-of-dicts for each
        detected components.
        """
        rois = pd.read_csv(self.fname, index_col=0)
        crds = []
        for roi in rois.itertuples():
            crd = self._generate_roi_xy(roi)
            com = np.array([roi.BX + roi.Width/2, roi.BY + roi.Height/2])
            bbox = [crd[0, 0], crd[1, 0], crd[0, 1], crd[2, 1]]
            crds.append({
                "coordinates": crd,
                "CoM": com,
                "neuron_id": roi.Index,
                "bbox": bbox,
            })
        return np.array(crds)

    def _generate_roi_xy(self, roi):
        """
        Receives a nametuple from pandas' itertuples() method which
        contains the bounding box of the ROI in question, and
        returns it in a similar structure to CaImAn's "crd" variable.
        """
        crd = np.zeros((4, 2), dtype=np.float64)
        crd[0, :] = roi.BX, roi.BY
        crd[1, :] = roi.BX + roi.Width, roi.BY
        crd[2, :] = roi.BX + roi.Width, roi.BY + roi.Height
        crd[3, :] = roi.BX, roi.BY + roi.Height
        return crd

    def _extract_dff_from_masks(self, rois: List, fps: float):
        """
        Extracts a specific raw trace from the loaded movie
        and calculates the dF/F values.
        """
        traces = np.zeros((len(rois), self.movie.shape[0]))
        for idx, roi in enumerate(rois):
            mask = roi['bbox']
            mask = [int(m) for m in mask]
            trace = self.movie[:, mask[0]:mask[1], mask[2]:mask[3]].mean((1, 2))
            traces[idx, :] = trace

        return DffCalculator(traces, fps=float(fps)).calc()


    def _write_results(self, params, cn, crd, dff):
        """ Writes the data to disk as a mock results.npz file """
        np.savez(self.results_fname, params=params, Cn=cn, crd=crd, F_dff=dff)



def parse_rois(foldername: pathlib.Path, glob='*rois.csv'):
    """ Parses all rois.csv files in a folder into results.npz files """
    for file in foldername.glob(glob):
        ParseFijiRoiCsv(file).run()


if __name__ == '__main__':
    foldername = pathlib.Path('/data/Amit_QNAP/WFA/Activity/WT_RGECO/20190916/')
    parse_rois(foldername)
